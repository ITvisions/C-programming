//
//  pointer.c
//  demo
//
//  Created by vision chen on 2021/4/11.
//

#include "pointer.h"
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include "swap.h"
#include "right_swap.h"
#include "arr_max.h"
#include "strlong.h"
void pointer(){
    int a = 10;
    char str[20] = "c.biancheng.net";
    printf("%#X,%#X\n",&a,str);
    // 数据和代码都以二进制的形式存储在内存中，计算机无法从格式上区分某块内存到底存储的是数据还是代码。当程序被加载到内存后，操作系统会给不同的内存块指定不同的权限，拥有读取和执行权限的内存块就是代码，而拥有读取和写入权限（也可能只有读取权限）的内存块就是数据。
    // CPU 访问内存时需要的是地址，而不是变量名和函数名！变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。编译和链接过程的一项重要任务就是找到这些名称所对应的地址
    // 假设变量 a、b、c 在内存中的地址分别是 0X1000、0X2000、0X3000，那么加法运算c = a + b;将会被转换成类似下面的形式
    // 0X3000 = (0X1000) + (0X2000);  ()表示取值操作，整个表达式的意思是，取出地址 0X1000 和 0X2000 上的值，将它们相加，把相加的结果赋值给地址为 0X3000 的内存
    // 变量名表示的是数据本身，而函数名、字符串名和数组名表示的是代码块或数据块的首地址
    // 在C语言中，允许用一个变量来存放指针，这种变量称为指针变量。指针变量的值就是某份数据的地址，这样的一份数据可以是数组、字符串、函数，也可以是另外的一个普通变量或指针变量
    // 定义指针变量格式为: datatype *name; 或者 datatype *name = value;
    // *表示这是一个指针变量，datatype表示该指针变量所指向的数据的类型
    int *p_a = &a;
    printf("&a = %#X\n",*p_a);
    //在定义指针变量 p_a 的同时对它进行初始化，并将变量 a 的地址赋予它，此时 p_a 就指向了 a。值得注意的是，p_a 需要的一个地址，a 前面必须要加取地址符&，否则是不对的
    // 和普通变量一样，指针变量也可以被多次写入
    float b = 99.5;
    p_a = &b;
    printf("&b = %#X\n",*p_a);
    p_a = &a;
    printf("&a = %#X\n",*p_a);
    // *是一个特殊符号，表明一个变量是指针变量,定义指针变量时必须带*，而给指针变量赋值时，因为已经知道了它是一个指针变量，就没必要多此一举再带上*，后边可以像使用普通变量一样来使用指针变量。也就是说，定义指针变量时必须带*，给指针变量赋值时不能带*
    float c = 0.99;
    char d = '@';
    float *p2;
    char *p3;
    p2 = &c;
    p3 = &d;
    printf("&b = %#X,&c = %#X\n", p2, p3);
    //p2、p3 的类型分别是float*和char*，而不是float和char，它们是完全不同的数据类型
    // 指针变量存储了数据的地址，通过指针变量能够获得该地址上的数据，格式为*pointer;
    printf("c = %f, d = %c\n",*p2,*p3);
    // 假设 a 的地址是 0X1000，p 指向 a 后，p 本身的值也会变为 0X1000，*p 表示获取地址 0X1000 上的数据，也即变量 a 的值。从运行结果看，*p 和 a 是等价的
    // CPU 读写数据必须要知道数据在内存中的地址，普通变量和指针变量都是地址的助记符，虽然通过 *p 和 a 获取到的数据一样，但它们的运行过程稍有不同：a 只需要一次运算就能够取得数据，而 *p 要经过两次运算，多了一层“间接”
    // 使用指针是间接获取数据，使用变量名是直接获取数据，前者比后者的代价要高
    // 指针除了可以获取内存上的数据，也可以修改内存上的数
    int e = 15, f = 99, g = 222;
    int *p6 = &e;
    *p6 = f; // 通过指针变量修改内存上的数据
    g = *p6; // 通过指针变量获取内存上的数据
    printf("%d,%d,%d,%d\n",e,f,g,*p6);
    // *在不同的场景下有不同的作用：*可以用在指针变量的定义中，表明这是一个指针变量，以和普通变量区分开；使用指针变量时在前面加*表示获取指针指向的数据，或者说表示的是指针指向的数据本身
    // 通过指针交换两个变量的值
    int k1 = 999, k2 = 100, temp;
    int *kp1 = &k1 , *kp2 = &k2;
    printf("k1 = %d, k2 = %d\n",k1,k2);
    /**开始交换**/
    temp = *kp1;
    *kp1 = *kp2;
    *kp2 = temp;
    /**交换结束**/
    printf("k1 = %d, k2 = %d\n",k1,k2);
    // 假设有一个 int 类型的变量 a，pa 是指向它的指针
    // *&a可以理解为*(&a)，&a表示取变量 a 的地址（等价于 pa），*(&a)表示取这个地址上的数据（等价于 *pa），绕来绕去，又回到了原点，*&a仍然等价于 a
    // &*pa可以理解为&(*pa)，*pa表示取得 pa 指向的数据（等价于 a），&(*pa)表示数据的地址（等价于 &a），所以&*pa等价于 pa
    
    //指针变量保存的是地址，而地址本质上是一个整数，所以指针变量可以进行部分运算
    int s = 12,*sa = &s,*ssa = &s;
    double y = 99.9, *sy = &y;
    char z = '&', *sz = &z;
    printf("&s=%#X,&y=%#X,&z=%#X\n",&s,&y,&z);
    printf("&sa=%#X,&sy=%#X,&sz=%#X\n",sa,sy,sz);
    sa++;sy++;sz++;
    printf("&sa=%#X,&sy=%#X,&sz=%#X\n",sa,sy,sz);
    sa -= 2 ; sy -= 2 ; sz -= 2;
    printf("&sa=%#X,&sy=%#X,&sz=%#X\n",sa,sy,sz);
    if (sa == ssa) {
        printf("sa == ssa,%d\n",*ssa);
    } else {
        printf("sa != ssa,%d\n",*sa);
    }
    // 引入数组指针后，我们就有两种方案来访问数组元素了，一种是使用下标，另外一种是使用指针
    // 1. 使用下标
    // 也就是采用 arr[i] 的形式访问数组元素。如果 p 是指向数组 arr 的指针，那么也可以使用 p[i] 来访问数组元素，它等价于 arr[i]
    // 2. 使用指针
    // 也就是使用 *(p+i) 的形式访问数组元素。另外数组名本身也是指针，也可以使用 *(arr+i) 来访问数组元素，它等价于 *(p+i)
    char str1[] = "https://baidu.com";
    char *pstr = str1;
    int len = strlen(str1),i;
    for ( i = 0; i < len; i++) {
        printf("%c",*(pstr + i));
    }
    printf("\n");
    for ( i = 0 ; i < len ; i++) {
        printf("%c",pstr[i]);
    }
    printf("\n");
    //除了字符数组，C语言还支持另外一种表示字符串的方法，就是直接使用一个指针指向字符串,str2指向首地址
    char *str2 = "http://dddd.com";
    // 改表示字符串的方法跟字符数组相似，但是也有区别
    // 它们最根本的区别是在内存中的存储区域不一样，字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限
    // 由于权限不同，字符数组在定义后可以读取和修改每个字符，而对于第二种形式的字符串，一旦被定义后就只能读取不能修改，任何对它的赋值都是错误的
    // 使用字符数组还是字符串常量：在编程过程中如果只涉及到对字符串的读取，那么字符数组和字符串常量都能够满足要求；如果有写入（修改）操作，那么只能使用字符数组，不能使用字符串常量
    
    // 指针变量作为函数参数
    // 像数组、字符串、动态分配的内存等都是一系列数据的集合，没有办法通过一个参数全部传入函数内部，只能传递它们的指针，在函数内部通过指针来影响这些数据集合
    // 有的时候，对于整数、小数、字符等基本类型数据的操作也必须要借助指针，一个典型的例子就是交换两个变量的值
    int aa = 66, bb = 99;
    swap(aa, bb);
    printf("aa = %d, bb = %d\n",aa,bb); // aa = 66, bb = 99
    // 可以看到aa和bb的值并没有交换，这是因为 swap() 函数内部的 a、b 和 main() 函数内部的 a、b 是不同的变量，占用不同的内存，它们除了名字一样，没有其他任何关系，swap() 交换的是它内部 a、b 的值，不会影响它外部
    // 要解决这个问题，可以使用指针变量作参数
    right_swap(&aa,&bb);
    printf("aa = %d, bb=%d\n",aa,bb); // aa = 99, bb=66
    // 数组是一系列数据的集合，无法通过参数将它们一次性传递到函数内部，如果希望在函数内部操作数组，必须传递数组指针。下面的例子定义了一个函数 arr_max()，用来查找数组中值最大的元素：
    int arr1[] = {2,21,432,2,1,76};
    int len1 = sizeof(arr1) / sizeof(int);
    printf("max number of arr is: %d\n",arr_max(arr1, len1));
    //不管使用哪种方式传递数组，都不能在函数内部求得数组长度，因为 intArr 仅仅是一个指针，而不是真正的数组，所以必须要额外增加一个参数来传递数组长度
    // C语言为什么不允许直接传递数组的所有元素，而必须传递数组指针:参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上
    // 对于像 int、float、char 等基本类型的数据，它们占用的内存往往只有几个字节，对它们进行内存拷贝非常快速。而数组是一系列数据的集合，数据的数量没有限制，可能很少，也可能成千上万，对它们进行内存拷贝有可能是一个漫长的过程，会严重拖慢程序的效率
    
    // 指针作为函数返回值
    // 函数的返回值是一个指针（地址），我们将这样的函数称为指针函数
    // 函数 strlong()用来返回两个字符串中较长的一个
    char *str11 = "http://fasdfhasdffkjas.com";
    char *str22 = "https://afdfcjccfajf.com";
    char *str33 = strlong(str11, str22);
    printf("longer string is : %s\n",str33);
    // 用指针作为函数返回值时需要注意: 函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针请尽量不要指向这些数据
    
    // 二级指针
    // 如果一个指针指向的是另外一个指针，我们就称它为二级指针，或者指向指针的指针
    int aa1 = 1000;
    int *ps = &aa1;
    int **pss = &ps;
    int ***psss = &pss;
    printf("%d,%d,%d,%d\n",aa1,*ps,**pss,***psss);
    printf("&pss = %#X, psss = %#X\n",&pss,psss);
    printf("&ps = %#X, pss = %#X\n",&ps,pss);
    printf("&ps = %#X, pss = %#X, *psss = %#X\n",&ps,pss,*psss);
    printf("&a = %#X, ps = %#X, *pss = %#X, *psss = %#X \n",&aa1,ps,*pss,**psss);
}
